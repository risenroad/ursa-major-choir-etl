# Ursa Major Choir ETL — Data Contract

## Goal
Turn a single "wide" Google Sheet (manual input) into a set of stable tables (tabs) for:
- dashboarding
- Telegram alerts (missed rehearsals, missed rehearsals with a specific song)

Update cadence: weekly.

---

## Source (RAW)
Spreadsheet tab: `main`

### Columns
Fixed columns:
- `Tag` (string) — entity type / voice part marker
- `Joined` (date) — join date of chorister (or row effective date if person changed voice part)
- `tgid` (string) — Telegram ID / username (optional but preferred)
- `Who` (string) — chorister full name OR song name (when Tag=Song)

Date columns:
- starting from column E: headers are rehearsal dates in format `dd.mm.yy`

### Semantics
Rows:
- Chorister rows: `Tag` is one of voice parts (e.g., Alto/Bass/Tenor/Soprano). Prefix `ex` means inactive (ex-member).
- Song rows: `Tag = Song`, and `Who` contains song title.

Cells under a date column:
- Chorister rows: value = `hours_attended` (number), empty = no attendance record (treated as absence by default).
- Song rows: value = `minutes_spent` (number), empty = song was not rehearsed that day.

Default assumption (can be revised later):
- empty attendance cell => absence (not "not filled in").

---

## Target (CURATED TABLES AS TABS)
Each tab is a table. All target tabs live in the same spreadsheet.

### DIMENSIONS

#### `dim_chorister`
Grain: 1 row per chorister (person).

Columns:
- `chorister_id` (string) — stable ID generated by ETL
- `tgid` (string, nullable)
- `full_name` (string)
- `joined_date` (date)
- `created_at` (datetime)
- `updated_at` (datetime)

ID rule:
- if `tgid` present => `chorister_id = "tgid:" + tgid`
- else => `chorister_id = "name_joined:" + normalize(full_name) + ":" + joined_date`

#### `dim_chorister_assignment`
Grain: 1 row per (chorister, voice_part, period).

Columns:
- `assignment_id` (string)
- `chorister_id` (string)
- `voice_part` (string)
- `is_active` (bool)
- `valid_from` (date)
- `valid_to` (date, nullable)

Rules:
- `is_active = false` if Tag starts with `ex`, else true
- `voice_part = Tag without "ex" prefix`
- default period:
  - `valid_from = joined_date`
  - `valid_to = NULL`
Note: true historical changes are only possible if they are reflected as separate rows in RAW.

#### `dim_song`
Grain: 1 row per song.

Columns:
- `song_id` (string)
- `song_name` (string)
- `created_at` (datetime)
- `updated_at` (datetime)

ID rule:
- `song_id = "song:" + normalize(song_name)`

---

### FACTS

#### `fact_attendance`
Grain: 1 row per (chorister_id, rehearsal_date) — **all pairs**, including empty cells (empty = missed rehearsal).

Columns:
- `rehearsal_date` (date, YYYY-MM-DD)
- `chorister_id` (string)
- `hours_attended` (number; 0 for empty cell)
- `missed_flag` (int 0 or 1: 1 if source cell was empty)
- `load_ts` (datetime)

Rules:
- Created by unpivoting RAW chorister rows × date columns: **every** chorister × **every** date column gets a row.
- Empty cell → `hours_attended = 0`, `missed_flag = 1`.
- Non-empty cell → `hours_attended = parse_float(value)` (comma → dot), `missed_flag = 0`; invalid value → RuntimeError with (chorister_id, rehearsal_date, raw_value).
- Date column headers are normalized to ISO; duplicate dates after normalization → RuntimeError.

#### `fact_song_time`
Grain: 1 row per (song_id, rehearsal_date) where song minutes are recorded.

Columns:
- `rehearsal_date` (date)
- `song_id` (string)
- `minutes_spent` (number)
- `load_ts` (datetime)

Rules:
- created by unpivoting RAW song rows across date columns
- skip empty cells (no record)

---

### MARTS (FOR DASHBOARD & ALERTS)

#### `mart_attendance`
Grain: 1 row per (rehearsal_date, chorister_id) from `fact_attendance`.

Columns:
- `rehearsal_date` (date, YYYY-MM-DD)
- `chorister_id` (string)
- `full_name` (string)
- `joined_date` (date, display)
- `voice_part` (string)
- `is_active` (bool)
- `hours_attended` (number)
- `attended_flag` (int 0 or 1: 1 if hours_attended > 0)
- `missed_flag` (int 0 or 1, from fact_attendance)
- `available_flag` (int 0 or 1: 1 if rehearsal_date >= joined_date)

Rules:
- Built from `dim_chorister`, `dim_chorister_assignment`, `fact_attendance`.
- `voice_part` and `is_active` resolved per rehearsal_date from `dim_chorister_assignment` (valid_from/valid_to).

#### `mart_song_rehearsal`
Grain: 1 row per (song_id, rehearsal_date) from `fact_song_time`.

Columns:
- `rehearsal_date` (date)
- `song_id` (string)
- `song_name` (string)
- `minutes_spent` (number)
- `hours_spent` (number, minutes_spent / 60)

Rules:
- Built from `dim_song`, `fact_song_time`.

#### `mart_chorister_song`
Grain: 1 row per (rehearsal_date, chorister_id, song_id) where the chorister attended (hours_attended > 0) and the song was rehearsed that day.

Columns:
- `rehearsal_date` (date)
- `chorister_id` (string)
- `full_name` (string)
- `joined_date` (string)
- `voice_part` (string)
- `song_id` (string)
- `song_name` (string)
- `minutes_spent` (number)
- `hours_spent` (number)

Rules:
- Built from `dim_chorister`, `dim_chorister_assignment`, `dim_song`, `fact_attendance`, `fact_song_time`.
- Only dates where chorister has hours_attended > 0 and song has minutes_spent for that date.

---

## TECH TABS

### `etl_log`
Grain: 1 row per ETL run.

Columns:
- `run_ts` (datetime)
- `status` (string: success|failed)
- `rows_dim_chorister` (int)
- `rows_dim_chorister_assignment` (int)
- `rows_dim_song` (int)
- `rows_fact_attendance` (int)
- `rows_fact_song_time` (int)
- `error_message` (string, nullable)

### `bad_cells`
Grain: 1 row per invalid source cell.

Columns:
- `entity_type` (chorister|song)
- `tag` (string)
- `who` (string)
- `rehearsal_date` (date)
- `raw_value` (string)
- `error_reason` (string)
- `run_ts` (datetime)

---

## Alerts (Telegram)
Planned weekly alerts:
1) missed rehearsals > 4 in the last N weeks (default N=12)
2) missed rehearsals where a specific song was rehearsed (song filter)
